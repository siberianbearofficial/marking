import cv2
from pyzbar import pyzbar
import sys

def damerau_levenshtein(s1, s2):
    """
    Находит расстояние по Дамерау-Левенштейну между двумя строками. 
    
    Параметры:
        s1: первая строка.
        s2: вторая строка.
    
    Возвращаемое значение:
        score: целочисленное расстояние между строками.
    """
    d = {}
    len_s1 = len(s1)
    len_s2 = len(s2)
    for i in range(-1, len_s1 + 1):
        d[(i, -1)] = i + 1
    for j in range(-1, len_s2 + 1):
        d[(-1, j)] = j + 1

    for i in range(len_s1):
        for j in range(len_s2):
            cost = 0 if s1[i] == s2[j] else 1
            d[(i, j)] = min(
                d[(i - 1, j)] + 1,  
                d[(i, j - 1)] + 1,  
                d[(i - 1, j - 1)] + cost  
            )
            if i and j and s1[i] == s2[j - 1] and s1[i - 1] == s2[j]:
                d[(i, j)] = min(
                    d[(i, j)],
                    d[(i - 2, j - 2)] + cost  
                )

    return d[len_s1 - 1, len_s2 - 1]

def similarity_score(s1, s2):
    """
    Оценивает схожесть двух строк используя расстояние Дамерау-Левенштейна между ними, нормализованное по длинне. 
    
    Параметры:
        s1: первая строка.
        s2: вторая строка.
    
    Возвращаемое значение:
        score: нормализованная оценка схожести строк, представленная на отрезке от 0 до 1.
    """
    if s1 == s2:
        return 1.0
    len_s1 = len(s1)
    len_s2 = len(s2)
    if len_s1 == 0 or len_s2 == 0:
        return 0.0

    distance = damerau_levenshtein(s1, s2)
    max_len = max(len_s1, len_s2)
    return 1 - distance / max_len

# TODO: создать отдельную структуру под баркод, чтобы не было такого ужаса в ретерне (и лучше туда все сохранять, начиная от бинарного представления баркода, заканчивая типом и ббоксом)
def decode_barcode(image):
    """
    Обнаруживает баркод на изображении. Если на изображении представлено несколько баркодов, то находит только последний из них. 
    Так как стандартные инструменты OpenCV часто не захватывают весь баркод внутрь ограничивающей рамки, предсмотрен механизм для увеличения ограничивающей рамки (пока хардкод!).
    
    Параметры:
        img: структура с изображением из CV2.
    
    Возвращаемое значение:
        text: текст в формате <бинарный код> (<тип баркода>).
        quad: четырехугольник в виде списка четырех точек - ограничивающая рамка распознанного баркода. Равен None в случае отсутствия возможности распознать баркод на изображении.
    """
    barcodes = pyzbar.decode(image)
    quad = None
    text = ""
    for barcode in barcodes:
        (x, y, w, h) = barcode.rect
        cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)
        
        barcode_data = barcode.data.decode("utf-8")
        barcode_type = barcode.type

        padding = 60
        # TODO: добавить адаптивное расширение баркода; сделать автоматический механизм поиска оптимального паддинга
        x = max(0, x - padding)
        y = max(0, y - padding)
        w += 2 * padding
        h += 2 * padding
        
        text = "{} ({})".format(barcode_data, barcode_type)

        quad = [[x, y], [x + w, y], [x + w, y + h], [x, y + h]]

    return text, quad

# TODO: а что если баркодов несколько? Причем если их несколько на изначальной маркеровке - это одно, а если несколько только на образце, то надо искать наиболее похожий.
def detect_barcode_zone(sample_path: str, ground_truth_path: str = None):
    """
    Обнаруживает ограничивающую рамку (bounding box) предполагаемого баркода и оценивает схожесть баркодов (через расстояние Дамерау-Левенштейна распознанных строк) в виде нормализованного числа от 0 до 1.
    Возвращаемая ограничивающая рамка необходима для валидацией пользователем той предполагаемой области изображения, в которой содержится баркод, на предмет его фактического нахождения.
    Если на изображении представлено несколько баркодов, возвращает последний распознанный из них (временное? допущение).
    
    Параметры:
        sample_path: строка, содержащая путь к изображению с предполагаемым баркодом.
        ground_truth_path: строка, содержащая путь к изображению с эталоном
    
    Возвращаемое значение:
        quad: четырехугольник в виде списка четырех точек - ограничивающая рамка распознанного баркода. Равен None в случае отсутствия возможности распознать баркод на изображении.
        score: схожесть баркодов (образца и эталона), выраженная числом на отрезке от 0 до 1.
    """

    if ground_truth_path is not None:
        image = cv2.imread(ground_truth_path)
        
        gt_text, _ = decode_barcode(image)
    else:
        gt_text = ""

    image = cv2.imread(sample_path)

    s_text, s_bbox = decode_barcode(image)

    return s_bbox, similarity_score(gt_text, s_text)
    
if __name__ == '__main__':
    quad, score = detect_barcode_zone(sys.argv[2], sys.argv[1])
    print(f'quad = {quad}; score = {score}')
